import { z } from 'zod';
import { failureClassificationSchema } from './failure';

/**
 * Error proposal schema - Full record
 */
export const errorProposalSchema = z.object({
  id: z.number().int().positive(),
  testFailureId: z.number().int().positive(),
  specId: z.string().nullable(),
  generatedAt: z.date(),
  lastFailureAt: z.date(),
  autoGeneratedContent: z.string().nullable(), // JSON string
  userModified: z.boolean().default(false),
  occurrenceCount: z.number().int().positive().default(1),
});

export type ErrorProposal = z.infer<typeof errorProposalSchema>;

/**
 * Auto-generated proposal content structure
 */
export const autoGeneratedContentSchema = z.object({
  title: z.string(),
  why: z.string(),
  whatChanges: z.string(),
  tasks: z.string(),
  classification: failureClassificationSchema,
  priority: z.number().int().min(1).max(5),
  errorType: z.enum([
    'type-error',
    'missing-property',
    'assertion-failure',
    'network-error',
    'configuration-error',
    'other',
  ]),
});

export type AutoGeneratedContent = z.infer<typeof autoGeneratedContentSchema>;

/**
 * Proposal generation request
 */
export const proposalGenerationSchema = z.object({
  testFailureId: z.number().int().positive(),
  projectId: z.number().int().positive(),
  projectPath: z.string(),
  forceRegenerate: z.boolean().default(false), // Regenerate even if exists
});

export type ProposalGenerationInput = z.infer<typeof proposalGenerationSchema>;

/**
 * Link error proposal to existing spec
 */
export const proposalLinkSchema = z.object({
  errorProposalId: z.number().int().positive(),
  existingSpecId: z.string().min(1),
});

export type ProposalLinkInput = z.infer<typeof proposalLinkSchema>;

/**
 * List error proposals query
 */
export const listErrorProposalsSchema = z.object({
  projectId: z.number().int().positive().optional(),
  classification: failureClassificationSchema.optional(),
  priority: z.number().int().min(1).max(5).optional(),
  sortBy: z.enum(['occurrences', 'priority', 'date']).default('occurrences'),
  includeLinked: z.boolean().default(false), // Include proposals already linked to specs
  limit: z.number().int().positive().max(100).default(50),
  offset: z.number().int().nonnegative().default(0),
});

export type ListErrorProposalsInput = z.infer<typeof listErrorProposalsSchema>;

/**
 * Get error proposal detail
 */
export const getErrorProposalSchema = z.object({
  errorProposalId: z.number().int().positive(),
});

export type GetErrorProposalInput = z.infer<typeof getErrorProposalSchema>;

/**
 * Error proposal with full details (joined data)
 */
export const errorProposalDetailSchema = errorProposalSchema.extend({
  testFailure: z.object({
    testName: z.string(),
    testFile: z.string().optional(),
    error: z.string().optional(),
    stackTrace: z.string().optional(),
  }),
  spec: z.object({
    id: z.string(),
    title: z.string(),
    status: z.string(),
  }).nullable(),
  parsedContent: autoGeneratedContentSchema.nullable(),
});

export type ErrorProposalDetail = z.infer<typeof errorProposalDetailSchema>;

/**
 * Error proposal statistics
 */
export const errorProposalStatsSchema = z.object({
  totalProposals: z.number().int().nonnegative(),
  byClassification: z.object({
    NEW: z.number().int().nonnegative(),
    FLAKY: z.number().int().nonnegative(),
    RECURRING: z.number().int().nonnegative(),
    PERSISTENT: z.number().int().nonnegative(),
  }),
  byPriority: z.object({
    p1: z.number().int().nonnegative(), // Priority 1
    p2: z.number().int().nonnegative(),
    p3: z.number().int().nonnegative(),
    p4: z.number().int().nonnegative(),
    p5: z.number().int().nonnegative(),
  }),
  linkedToSpecs: z.number().int().nonnegative(),
  pendingReview: z.number().int().nonnegative(),
});

export type ErrorProposalStats = z.infer<typeof errorProposalStatsSchema>;

/**
 * Regenerate error proposal
 */
export const regenerateProposalSchema = z.object({
  errorProposalId: z.number().int().positive(),
  projectPath: z.string(),
});

export type RegenerateProposalInput = z.infer<typeof regenerateProposalSchema>;

/**
 * Error proposal subscription input
 */
export const errorProposalSubscriptionSchema = z.object({
  projectId: z.number().int().positive().optional(),
});

export type ErrorProposalSubscriptionInput = z.infer<typeof errorProposalSubscriptionSchema>;

/**
 * Error proposal event types
 */
export const errorProposalEventSchema = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('proposal_generated'),
    errorProposalId: z.number().int().positive(),
    testFailureId: z.number().int().positive(),
    specId: z.string().nullable(),
    priority: z.number().int().min(1).max(5),
    classification: failureClassificationSchema,
  }),
  z.object({
    type: z.literal('proposal_updated'),
    errorProposalId: z.number().int().positive(),
    occurrenceCount: z.number().int().positive(),
    lastFailureAt: z.date(),
  }),
  z.object({
    type: z.literal('priority_escalated'),
    errorProposalId: z.number().int().positive(),
    oldPriority: z.number().int().min(1).max(5),
    newPriority: z.number().int().min(1).max(5),
    reason: z.string(),
  }),
  z.object({
    type: z.literal('proposal_linked'),
    errorProposalId: z.number().int().positive(),
    specId: z.string(),
  }),
]);

export type ErrorProposalEvent = z.infer<typeof errorProposalEventSchema>;

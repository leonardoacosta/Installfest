/**
 * Error Proposals Router
 *
 * Handles automatic error proposal generation from test failures.
 */

import { z } from 'zod';
import { eq, and, desc, isNotNull, inArray } from 'drizzle-orm';
import { observable } from '@trpc/server/observable';
import { createTRPCRouter, publicProcedure } from '../trpc';
import { errorProposals, testFailures, openspecSpecs } from '@homelab/db';
import { ErrorProposalGenerator } from '../services/error-proposal-generator';
import { errorProposalEvents } from '../events';
import type { ErrorProposalEvent } from '@homelab/validators';
import {
  listErrorProposalsSchema,
  getErrorProposalSchema,
  proposalLinkSchema,
  regenerateProposalSchema,
  errorProposalSubscriptionSchema,
} from '@homelab/validators';

export const errorProposalsRouter = createTRPCRouter({
  /**
   * List pending error proposals
   */
  listPending: publicProcedure
    .input(listErrorProposalsSchema)
    .query(async ({ ctx, input }) => {
      let query = ctx.db
        .select({
          id: errorProposals.id,
          testFailureId: errorProposals.testFailureId,
          specId: errorProposals.specId,
          generatedAt: errorProposals.generatedAt,
          lastFailureAt: errorProposals.lastFailureAt,
          occurrenceCount: errorProposals.occurrenceCount,
          userModified: errorProposals.userModified,
          autoGeneratedContent: errorProposals.autoGeneratedContent,
          testName: testFailures.testName,
          testFile: testFailures.testFile,
          error: testFailures.error,
          specTitle: openspecSpecs.title,
          specStatus: openspecSpecs.status,
        })
        .from(errorProposals)
        .innerJoin(testFailures, eq(errorProposals.testFailureId, testFailures.id))
        .leftJoin(openspecSpecs, eq(errorProposals.specId, openspecSpecs.id))
        .$dynamic();

      // Filter by project if specified
      if (input.projectId) {
        query = query.where(eq(openspecSpecs.projectId, input.projectId));
      }

      // Filter by classification if specified
      if (input.classification) {
        // Parse autoGeneratedContent to filter by classification
        // This is a workaround since SQLite doesn't support JSON queries easily
        // In production, consider denormalizing classification to a column
      }

      // Filter linked vs unlinked
      if (!input.includeLinked) {
        query = query.where(isNotNull(errorProposals.specId));
      }

      // Sorting
      if (input.sortBy === 'occurrences') {
        query = query.orderBy(desc(errorProposals.occurrenceCount));
      } else if (input.sortBy === 'date') {
        query = query.orderBy(desc(errorProposals.generatedAt));
      }
      // Priority sorting would require parsing JSON, skip for now

      // Pagination
      query = query.limit(input.limit).offset(input.offset);

      const results = await query.all();

      // Parse autoGeneratedContent for each result
      return results.map(result => ({
        ...result,
        parsedContent: result.autoGeneratedContent
          ? JSON.parse(result.autoGeneratedContent)
          : null,
      }));
    }),

  /**
   * Get detailed error proposal
   */
  get: publicProcedure
    .input(getErrorProposalSchema)
    .query(async ({ ctx, input }) => {
      const result = await ctx.db
        .select({
          id: errorProposals.id,
          testFailureId: errorProposals.testFailureId,
          specId: errorProposals.specId,
          generatedAt: errorProposals.generatedAt,
          lastFailureAt: errorProposals.lastFailureAt,
          occurrenceCount: errorProposals.occurrenceCount,
          userModified: errorProposals.userModified,
          autoGeneratedContent: errorProposals.autoGeneratedContent,
          testName: testFailures.testName,
          testFile: testFailures.testFile,
          error: testFailures.error,
          stackTrace: testFailures.stackTrace,
          specTitle: openspecSpecs.title,
          specStatus: openspecSpecs.status,
        })
        .from(errorProposals)
        .innerJoin(testFailures, eq(errorProposals.testFailureId, testFailures.id))
        .leftJoin(openspecSpecs, eq(errorProposals.specId, openspecSpecs.id))
        .where(eq(errorProposals.id, input.errorProposalId))
        .get();

      if (!result) {
        throw new Error(`Error proposal ${input.errorProposalId} not found`);
      }

      return {
        ...result,
        parsedContent: result.autoGeneratedContent
          ? JSON.parse(result.autoGeneratedContent)
          : null,
      };
    }),

  /**
   * Get error proposal statistics
   */
  stats: publicProcedure
    .input(
      z.object({
        projectId: z.number().int().positive().optional(),
      })
    )
    .query(async ({ ctx, input }) => {
      let query = ctx.db
        .select({
          id: errorProposals.id,
          specId: errorProposals.specId,
          autoGeneratedContent: errorProposals.autoGeneratedContent,
        })
        .from(errorProposals)
        .$dynamic();

      if (input.projectId) {
        query = query
          .leftJoin(openspecSpecs, eq(errorProposals.specId, openspecSpecs.id))
          .where(eq(openspecSpecs.projectId, input.projectId));
      }

      const proposals = await query.all();

      // Parse all proposals to extract classification and priority
      const parsed = proposals.map(p => ({
        ...p,
        content: p.autoGeneratedContent ? JSON.parse(p.autoGeneratedContent) : null,
      }));

      const stats = {
        totalProposals: proposals.length,
        byClassification: {
          NEW: parsed.filter(p => p.content?.classification === 'NEW').length,
          FLAKY: parsed.filter(p => p.content?.classification === 'FLAKY').length,
          RECURRING: parsed.filter(p => p.content?.classification === 'RECURRING').length,
          PERSISTENT: parsed.filter(p => p.content?.classification === 'PERSISTENT').length,
        },
        byPriority: {
          p1: parsed.filter(p => p.content?.priority === 1).length,
          p2: parsed.filter(p => p.content?.priority === 2).length,
          p3: parsed.filter(p => p.content?.priority === 3).length,
          p4: parsed.filter(p => p.content?.priority === 4).length,
          p5: parsed.filter(p => p.content?.priority === 5).length,
        },
        linkedToSpecs: proposals.filter(p => p.specId !== null).length,
        pendingReview: proposals.filter(p => p.specId !== null).length, // Simplified
      };

      return stats;
    }),

  /**
   * Link error proposal to existing spec
   */
  link: publicProcedure
    .input(proposalLinkSchema)
    .mutation(async ({ ctx, input }) => {
      // Verify spec exists
      const spec = await ctx.db
        .select()
        .from(openspecSpecs)
        .where(eq(openspecSpecs.id, input.existingSpecId))
        .get();

      if (!spec) {
        throw new Error(`Spec ${input.existingSpecId} not found`);
      }

      // Update error proposal
      const updated = await ctx.db
        .update(errorProposals)
        .set({ specId: input.existingSpecId })
        .where(eq(errorProposals.id, input.errorProposalId))
        .returning()
        .get();

      if (!updated) {
        throw new Error(`Error proposal ${input.errorProposalId} not found`);
      }

      // Emit event
      errorProposalEvents.emit('error-proposal:event', {
        type: 'proposal_linked',
        errorProposalId: updated.id,
        specId: input.existingSpecId,
      });

      return updated;
    }),

  /**
   * Regenerate error proposal with latest failure data
   */
  regenerate: publicProcedure
    .input(regenerateProposalSchema)
    .mutation(async ({ ctx, input }) => {
      // Get error proposal
      const proposal = await ctx.db
        .select()
        .from(errorProposals)
        .where(eq(errorProposals.id, input.errorProposalId))
        .get();

      if (!proposal) {
        throw new Error(`Error proposal ${input.errorProposalId} not found`);
      }

      // Get latest test failure for the same test
      const latestFailure = await ctx.db
        .select()
        .from(testFailures)
        .where(eq(testFailures.id, proposal.testFailureId))
        .get();

      if (!latestFailure) {
        throw new Error(`Test failure ${proposal.testFailureId} not found`);
      }

      // Regenerate proposal content
      const generator = new ErrorProposalGenerator(ctx.db);
      const changeNumber = proposal.specId
        ? parseInt(proposal.specId.match(/^(\d+)-/)?.[1] ?? '1', 10)
        : 1;

      const newContent = await generator.generateProposal(
        latestFailure.id,
        input.projectPath,
        changeNumber
      );

      // Update error proposal
      const updated = await ctx.db
        .update(errorProposals)
        .set({
          autoGeneratedContent: JSON.stringify(newContent),
          userModified: false, // Reset since we regenerated
        })
        .where(eq(errorProposals.id, input.errorProposalId))
        .returning()
        .get();

      return {
        ...updated,
        parsedContent: newContent,
      };
    }),

  /**
   * Get all related test failures for an error proposal
   */
  getRelatedFailures: publicProcedure
    .input(z.object({ errorProposalId: z.number().int().positive() }))
    .query(async ({ ctx, input }) => {
      // First get the error proposal to find the test name
      const proposal = await ctx.db
        .select({
          testName: testFailures.testName,
          testFile: testFailures.testFile,
        })
        .from(errorProposals)
        .innerJoin(testFailures, eq(errorProposals.testFailureId, testFailures.id))
        .where(eq(errorProposals.id, input.errorProposalId))
        .get();

      if (!proposal) {
        throw new Error(`Error proposal ${input.errorProposalId} not found`);
      }

      // Find all test failures with the same test name and file
      const relatedFailures = await ctx.db
        .select({
          id: testFailures.id,
          testName: testFailures.testName,
          testFile: testFailures.testFile,
          error: testFailures.error,
          stackTrace: testFailures.stackTrace,
          failedAt: testFailures.failedAt,
          classification: testFailures.classification,
        })
        .from(testFailures)
        .where(
          and(
            eq(testFailures.testName, proposal.testName),
            eq(testFailures.testFile, proposal.testFile)
          )
        )
        .orderBy(desc(testFailures.failedAt))
        .limit(50) // Limit to last 50 failures
        .all();

      return relatedFailures;
    }),

  /**
   * Subscribe to error proposal events
   * Streams: proposal_generated, proposal_updated, priority_escalated, proposal_linked
   */
  subscribe: publicProcedure
    .input(errorProposalSubscriptionSchema)
    .subscription(({ input }) => {
      return observable<ErrorProposalEvent>((emit) => {
        const listener = (event: ErrorProposalEvent) => {
          // Filter by projectId if specified (would need to join to check)
          // For now, emit all events
          emit.next(event);
        };

        errorProposalEvents.on('error-proposal:event', listener);

        return () => {
          errorProposalEvents.off('error-proposal:event', listener);
        };
      });
    }),
});
